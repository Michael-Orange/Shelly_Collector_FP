CONTEXTE
========
Application Shelly_Collector_FP refactoris√©e (Brief 1 compl√©t√© avec succ√®s).
Architecture modulaire : main.py + config.py + services/database.py + models/schemas.py.
Base de donn√©es : power_logs avec 15k+ enregistrements de pompes Shelly Pro 4PM.
Device unique : shellypro4pm-a0dd6c9ef474 avec 3 canaux (switch:0, switch:1, switch:2).

Objectif : Ajouter une interface web pour visualiser les cycles de marche/arr√™t des pompes.
Design : Style FiltrePlante.com (vert nature #2d8659, minimaliste, moderne).

PROBL√âMATIQUE
=============
Les pompes d√©marrent et s'arr√™tent, mais quand elles s'arr√™tent, aucun enregistrement √† 0W (filtr√© par Cloudflare Worker √† >10W).
‚Üí D√©tection d'arr√™t par "gap" dans les timestamps : si √©cart ‚â•3 minutes entre 2 mesures = pompe arr√™t√©e.
‚Üí Ignorer les cycles < 2 minutes (bruit, faux d√©marrages).
‚Üí Afficher les 45 derniers jours par d√©faut.

OBJECTIF
========
Ajouter 3 nouveaux composants √† l'application :

1. services/cycle_detector.py : Logique de d√©tection des cycles
2. api/routes.py : Endpoint GET /api/pump-cycles (retourne JSON)
3. web/dashboard.py : Page GET /dashboard (HTML complet avec charte FiltrePlante)

Am√©liorations techniques par rapport au brief initial :
- Utiliser datetime.now(timezone.utc) au lieu de datetime.utcnow() (deprecated Python 3.12+)
- Passer db_pool via app.state pour √©viter import circulaire
- Centraliser le device_id dans config.py

SP√âCIFICATIONS
===============

PARTIE 1 : CONFIGURATION
-------------------------

Modifier config.py pour ajouter :

# Device
SHELLY_DEVICE_ID = "shellypro4pm-a0dd6c9ef474"


PARTIE 2 : LOGIQUE DE D√âTECTION DES CYCLES
-------------------------------------------

Cr√©er services/cycle_detector.py :

"""
Module: cycle_detector
Description: D√©tection des cycles de marche/arr√™t des pompes
Created: 2026-02-13
Part of Shelly_Collector_FP
"""

from datetime import datetime, timezone, timedelta
from typing import List, Dict, Optional

def detect_cycles(
    records: List[tuple],
    gap_threshold_minutes: int = 3,
    min_duration_minutes: int = 2
) -> List[Dict]:
    """
    D√©tecte les cycles de marche/arr√™t √† partir des enregistrements.
    
    Args:
        records: Liste de tuples (timestamp, channel, apower_w)
                 Channel format attendu : "switch:0", "switch:1", "switch:2"
        gap_threshold_minutes: √âcart en minutes pour d√©tecter un arr√™t (d√©faut: 3)
        min_duration_minutes: Dur√©e minimale d'un cycle valide (d√©faut: 2)
        
    Returns:
        Liste de dictionnaires avec les cycles d√©tect√©s, tri√©e par date d√©croissante
        
    Format retour :
    {
        "channel": "switch:1",
        "start_time": datetime,
        "end_time": datetime ou None (si en cours),
        "duration_minutes": float,
        "avg_power_w": float,
        "records_count": int,
        "is_ongoing": bool
    }
    """
    if not records:
        return []
    
    cycles = []
    grouped_by_channel = {}
    
    # Grouper par canal
    for timestamp, channel, apower in records:
        if channel not in grouped_by_channel:
            grouped_by_channel[channel] = []
        grouped_by_channel[channel].append((timestamp, apower))
    
    # Analyser chaque canal
    for channel, channel_records in grouped_by_channel.items():
        if not channel_records:
            continue
        
        # Trier par timestamp
        channel_records.sort(key=lambda x: x[0])
        
        cycle_start = channel_records[0][0]
        cycle_powers = [channel_records[0][1]]
        
        for i in range(1, len(channel_records)):
            current_time = channel_records[i][0]
            current_power = channel_records[i][1]
            previous_time = channel_records[i-1][0]
            
            gap_minutes = (current_time - previous_time).total_seconds() / 60
            
            # Gap d√©tect√© = fin de cycle
            if gap_minutes >= gap_threshold_minutes:
                cycle_end = previous_time
                cycle_duration = (cycle_end - cycle_start).total_seconds() / 60
                
                # Valider dur√©e minimale
                if cycle_duration >= min_duration_minutes:
                    avg_power = sum(cycle_powers) / len(cycle_powers) if cycle_powers else 0
                    
                    cycles.append({
                        "channel": channel,
                        "start_time": cycle_start,
                        "end_time": cycle_end,
                        "duration_minutes": round(cycle_duration, 1),
                        "avg_power_w": round(avg_power, 1),
                        "records_count": len(cycle_powers),
                        "is_ongoing": False
                    })
                
                # Nouveau cycle commence
                cycle_start = current_time
                cycle_powers = [current_power]
            else:
                cycle_powers.append(current_power)
        
        # Dernier cycle (potentiellement en cours)
        if cycle_powers:
            cycle_end = channel_records[-1][0]
            cycle_duration = (cycle_end - cycle_start).total_seconds() / 60
            
            # V√©rifier si en cours (derni√®re mesure < gap_threshold)
            # ‚ö†Ô∏è Utiliser datetime.now(timezone.utc) au lieu de datetime.utcnow() (deprecated Python 3.12+)
            time_since_last = (datetime.now(timezone.utc) - cycle_end).total_seconds() / 60
            is_ongoing = time_since_last < gap_threshold_minutes
            
            if cycle_duration >= min_duration_minutes or is_ongoing:
                avg_power = sum(cycle_powers) / len(cycle_powers) if cycle_powers else 0
                
                cycles.append({
                    "channel": channel,
                    "start_time": cycle_start,
                    "end_time": cycle_end if not is_ongoing else None,
                    "duration_minutes": round(cycle_duration, 1),
                    "avg_power_w": round(avg_power, 1),
                    "records_count": len(cycle_powers),
                    "is_ongoing": is_ongoing
                })
    
    # Trier par date d√©croissante
    cycles.sort(key=lambda x: x["start_time"], reverse=True)
    
    return cycles


PARTIE 3 : ENDPOINT API
------------------------

Cr√©er le dossier api/ avec __init__.py vide.
Cr√©er api/routes.py :

"""
Module: routes
Description: API endpoints pour le dashboard
Created: 2026-02-13
Part of Shelly_Collector_FP
"""

from fastapi import APIRouter, Query, HTTPException, Request
from datetime import datetime, timezone, timedelta
from typing import Optional
import config
from services.cycle_detector import detect_cycles

router = APIRouter(prefix="/api")

@router.get("/pump-cycles")
async def get_pump_cycles(
    request: Request,
    channel: Optional[str] = Query(None, description="Filtrer par canal (ex: switch:1)"),
    start_date: Optional[str] = Query(None, description="Date d√©but ISO (ex: 2026-02-01)"),
    end_date: Optional[str] = Query(None, description="Date fin ISO (ex: 2026-02-14)"),
    limit: int = Query(1000, ge=1, le=10000, description="Nombre max de cycles")
):
    """
    Retourne les cycles de marche/arr√™t des pompes d√©tect√©s.
    
    Logique : Gap ‚â•3 minutes entre mesures = cycle termin√©.
    Filtre : Cycles de dur√©e minimale 2 minutes.
    D√©faut : 45 derniers jours.
    """
    # R√©cup√©rer db_pool depuis app.state (√©vite import circulaire)
    db_pool = request.app.state.db_pool
    
    try:
        # Dates par d√©faut : 45 derniers jours
        # ‚ö†Ô∏è Utiliser datetime.now(timezone.utc) au lieu de datetime.utcnow() (deprecated)
        if not start_date:
            start_dt = datetime.now(timezone.utc) - timedelta(days=config.DEFAULT_DAYS_HISTORY)
        else:
            start_dt = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
        
        if not end_date:
            end_dt = datetime.now(timezone.utc)
        else:
            end_dt = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
        
        # Requ√™te DB
        query = """
            SELECT timestamp, channel, apower_w
            FROM power_logs
            WHERE timestamp >= $1 AND timestamp <= $2
            AND device_id = $3
        """
        params = [start_dt, end_dt, config.SHELLY_DEVICE_ID]
        
        if channel:
            query += " AND channel = $4"
            params.append(channel)
        
        query += " ORDER BY channel, timestamp ASC"
        
        async with db_pool.acquire() as conn:
            records = await conn.fetch(query, *params)
        
        print(f"üìä API: Fetched {len(records)} records for cycle detection", flush=True)
        
        # Convertir en liste de tuples
        records_list = [(r['timestamp'], r['channel'], r['apower_w']) for r in records]
        
        # D√©tecter cycles
        cycles = detect_cycles(
            records_list,
            gap_threshold_minutes=config.GAP_THRESHOLD_MINUTES,
            min_duration_minutes=config.MIN_CYCLE_DURATION_MINUTES
        )
        
        print(f"üîç API: Detected {len(cycles)} cycles", flush=True)
        
        # Limiter r√©sultats
        cycles = cycles[:limit]
        
        # Formater pour JSON
        for cycle in cycles:
            cycle['start_time'] = cycle['start_time'].isoformat() + 'Z'
            if cycle['end_time']:
                cycle['end_time'] = cycle['end_time'].isoformat() + 'Z'
            else:
                cycle['end_time'] = None  # En cours
        
        return {
            "total": len(cycles),
            "device_id": config.SHELLY_DEVICE_ID,
            "filters": {
                "channel": channel,
                "start_date": start_dt.isoformat() + 'Z',
                "end_date": end_dt.isoformat() + 'Z'
            },
            "cycles": cycles
        }
    
    except Exception as e:
        print(f"‚ùå Error in /api/pump-cycles: {e}", flush=True)
        raise HTTPException(status_code=500, detail=f"Erreur serveur: {str(e)}")


PARTIE 4 : PAGE HTML DASHBOARD
-------------------------------

Cr√©er le dossier web/ avec __init__.py vide.
Cr√©er web/dashboard.py :

"""
Module: dashboard
Description: Interface web pour visualiser les cycles de pompes
Created: 2026-02-13
Part of Shelly_Collector_FP
Style: Charte graphique FiltrePlante.com (vert #2d8659)
"""

def render_dashboard() -> str:
    """Retourne le HTML complet du dashboard avec style FiltrePlante."""
    
    return """
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FiltrePlante - Monitoring Pompes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8f9fa;
            color: #2c3e50;
            line-height: 1.6;
        }
        
        /* Header style FiltrePlante */
        .header {
            background: linear-gradient(135deg, #2d8659 0%, #1a5738 100%);
            color: white;
            padding: 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 0.95rem;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        /* Filtres */
        .filters {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }
        
        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .filter-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #1a5738;
        }
        
        .filter-group select,
        .filter-group input {
            width: 100%;
            padding: 0.6rem;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: border-color 0.3s;
        }
        
        .filter-group select:focus,
        .filter-group input:focus {
            outline: none;
            border-color: #2d8659;
        }
        
        .buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        
        button {
            padding: 0.7rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #2d8659;
            color: white;
        }
        
        .btn-primary:hover {
            background: #1a5738;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(45, 134, 89, 0.3);
        }
        
        .btn-secondary {
            background: white;
            color: #2d8659;
            border: 2px solid #2d8659;
        }
        
        .btn-secondary:hover {
            background: #f0f8f4;
        }
        
        /* Statistiques */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .stat-card {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
            border-left: 4px solid #2d8659;
        }
        
        .stat-card .label {
            font-size: 0.85rem;
            color: #7f8c8d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-card .value {
            font-size: 2rem;
            font-weight: 700;
            color: #2d8659;
            margin-top: 0.5rem;
        }
        
        /* Tableau */
        .table-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        thead {
            background: #1a5738;
            color: white;
        }
        
        th {
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        tbody tr {
            border-bottom: 1px solid #ecf0f1;
            transition: background 0.2s;
        }
        
        tbody tr:hover {
            background: #f0f8f4;
        }
        
        tbody tr:nth-child(even) {
            background: #fafafa;
        }
        
        tbody tr:nth-child(even):hover {
            background: #f0f8f4;
        }
        
        td {
            padding: 1rem;
            font-size: 0.95rem;
        }
        
        .channel-badge {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .channel-switch-0 { background: #e3f2fd; color: #1976d2; }
        .channel-switch-1 { background: #f3e5f5; color: #7b1fa2; }
        .channel-switch-2 { background: #fff3e0; color: #f57c00; }
        
        .ongoing {
            color: #2d8659;
            font-weight: 600;
        }
        
        .loading {
            text-align: center;
            padding: 3rem;
            color: #7f8c8d;
        }
        
        .spinner {
            border: 3px solid #ecf0f1;
            border-top: 3px solid #2d8659;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .empty {
            text-align: center;
            padding: 3rem;
            color: #7f8c8d;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header {
                padding: 1.5rem;
            }
            
            .header h1 {
                font-size: 1.3rem;
            }
            
            .filters-grid {
                grid-template-columns: 1fr;
            }
            
            .buttons {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
            
            table {
                font-size: 0.85rem;
            }
            
            th, td {
                padding: 0.7rem 0.5rem;
            }
            
            .stat-card .value {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1><span>üå±</span> FiltrePlante - Monitoring des Pompes</h1>
        <p>Suivi en temps r√©el des cycles de d√©marrage et d'arr√™t ‚Ä¢ Shelly Pro 4PM</p>
    </div>
    
    <div class="container">
        <!-- Filtres -->
        <div class="filters">
            <div class="filters-grid">
                <div class="filter-group">
                    <label for="channel-filter">üíß Canal</label>
                    <select id="channel-filter">
                        <option value="">Tous les canaux</option>
                        <option value="switch:0">Canal 0</option>
                        <option value="switch:1">Canal 1</option>
                        <option value="switch:2">Canal 2</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="start-date">üìÖ Date d√©but</label>
                    <input type="date" id="start-date">
                </div>
                
                <div class="filter-group">
                    <label for="end-date">üìÖ Date fin</label>
                    <input type="date" id="end-date">
                </div>
            </div>
            
            <div class="buttons">
                <button class="btn-primary" onclick="loadCycles()">üîÑ Rafra√Æchir</button>
                <button class="btn-secondary" onclick="exportCSV()">üì• Exporter CSV</button>
            </div>
        </div>
        
        <!-- Statistiques -->
        <div class="stats">
            <div class="stat-card">
                <div class="label">Total cycles</div>
                <div class="value" id="stat-total">-</div>
            </div>
            <div class="stat-card">
                <div class="label">En cours</div>
                <div class="value" id="stat-ongoing">-</div>
            </div>
            <div class="stat-card">
                <div class="label">Dur√©e moyenne</div>
                <div class="value" id="stat-avg-duration">-</div>
            </div>
            <div class="stat-card">
                <div class="label">Puissance moy.</div>
                <div class="value" id="stat-avg-power">-</div>
            </div>
        </div>
        
        <!-- Tableau -->
        <div class="table-container">
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <p>Chargement des donn√©es...</p>
            </div>
            
            <div id="table-wrapper" style="display: none;">
                <table>
                    <thead>
                        <tr>
                            <th>Canal</th>
                            <th>Date</th>
                            <th>D√©marrage</th>
                            <th>Arr√™t</th>
                            <th>Dur√©e</th>
                            <th>Puissance moy.</th>
                        </tr>
                    </thead>
                    <tbody id="cycles-tbody">
                    </tbody>
                </table>
            </div>
            
            <div id="empty" class="empty" style="display: none;">
                <p>üì≠ Aucun cycle trouv√© pour cette p√©riode</p>
            </div>
        </div>
    </div>
    
    <script>
        let currentData = null;
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', () => {
            // D√©finir dates par d√©faut (45 derniers jours)
            const today = new Date();
            const startDate = new Date(today);
            startDate.setDate(today.getDate() - 45);
            
            document.getElementById('start-date').valueAsDate = startDate;
            document.getElementById('end-date').valueAsDate = today;
            
            // Charger donn√©es
            loadCycles();
        });
        
        async function loadCycles() {
            const channel = document.getElementById('channel-filter').value;
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            
            // Afficher loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('table-wrapper').style.display = 'none';
            document.getElementById('empty').style.display = 'none';
            
            try {
                // Construire URL
                let url = '/api/pump-cycles?';
                if (channel) url += `channel=${channel}&`;
                if (startDate) url += `start_date=${startDate}T00:00:00Z&`;
                if (endDate) url += `end_date=${endDate}T23:59:59Z&`;
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                
                currentData = data;
                
                // Cacher loading
                document.getElementById('loading').style.display = 'none';
                
                if (data.cycles.length === 0) {
                    document.getElementById('empty').style.display = 'block';
                    updateStats([]);
                    return;
                }
                
                // Afficher tableau
                document.getElementById('table-wrapper').style.display = 'block';
                renderTable(data.cycles);
                updateStats(data.cycles);
                
            } catch (error) {
                console.error('Erreur:', error);
                document.getElementById('loading').style.display = 'none';
                alert('Erreur lors du chargement des donn√©es: ' + error.message);
            }
        }
        
        function renderTable(cycles) {
            const tbody = document.getElementById('cycles-tbody');
            tbody.innerHTML = '';
            
            cycles.forEach(cycle => {
                const row = document.createElement('tr');
                
                // Canal
                const channelClass = 'channel-' + cycle.channel.replace(':', '-');
                const channelCell = `<td><span class="channel-badge ${channelClass}">${cycle.channel}</span></td>`;
                
                // Date (UTC+0 pour S√©n√©gal, pas de conversion n√©cessaire)
                const startDate = new Date(cycle.start_time);
                const dateStr = startDate.toLocaleDateString('fr-SN', { 
                    day: '2-digit', 
                    month: '2-digit', 
                    year: 'numeric' 
                });
                
                // Heure d√©marrage
                const startTimeStr = startDate.toLocaleTimeString('fr-SN', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                // Heure arr√™t
                let endTimeStr;
                if (cycle.is_ongoing) {
                    endTimeStr = '<span class="ongoing">En cours ‚ö°</span>';
                } else {
                    const endDate = new Date(cycle.end_time);
                    endTimeStr = endDate.toLocaleTimeString('fr-SN', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                }
                
                // Dur√©e
                const durationStr = `${cycle.duration_minutes} min`;
                
                // Puissance
                const powerStr = `${cycle.avg_power_w} W`;
                
                row.innerHTML = `
                    ${channelCell}
                    <td>${dateStr}</td>
                    <td>${startTimeStr}</td>
                    <td>${endTimeStr}</td>
                    <td>${durationStr}</td>
                    <td>${powerStr}</td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        function updateStats(cycles) {
            const total = cycles.length;
            const ongoing = cycles.filter(c => c.is_ongoing).length;
            
            let totalDuration = 0;
            let totalPower = 0;
            cycles.forEach(c => {
                totalDuration += c.duration_minutes;
                totalPower += c.avg_power_w;
            });
            
            const avgDuration = total > 0 ? Math.round(totalDuration / total) : 0;
            const avgPower = total > 0 ? Math.round(totalPower / total) : 0;
            
            document.getElementById('stat-total').textContent = total;
            document.getElementById('stat-ongoing').textContent = ongoing;
            document.getElementById('stat-avg-duration').textContent = `${avgDuration} min`;
            document.getElementById('stat-avg-power').textContent = `${avgPower} W`;
        }
        
        function exportCSV() {
            if (!currentData || currentData.cycles.length === 0) {
                alert('Aucune donn√©e √† exporter');
                return;
            }
            
            // Construire CSV (format fran√ßais : point-virgule)
            let csv = 'Canal;Date;Heure d√©marrage;Heure arr√™t;Dur√©e (min);Puissance moyenne (W);Statut\\n';
            
            currentData.cycles.forEach(cycle => {
                const startDate = new Date(cycle.start_time);
                const dateStr = startDate.toLocaleDateString('fr-SN');
                const startTimeStr = startDate.toLocaleTimeString('fr-SN');
                
                let endTimeStr = '';
                let status = 'Termin√©';
                if (cycle.is_ongoing) {
                    endTimeStr = '-';
                    status = 'En cours';
                } else {
                    const endDate = new Date(cycle.end_time);
                    endTimeStr = endDate.toLocaleTimeString('fr-SN');
                }
                
                csv += `${cycle.channel};${dateStr};${startTimeStr};${endTimeStr};${cycle.duration_minutes};${cycle.avg_power_w};${status}\\n`;
            });
            
            // T√©l√©charger
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `cycles_pompes_filtreplante_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
        }
    </script>
</body>
</html>
    """


PARTIE 5 : INT√âGRATION DANS MAIN.PY
------------------------------------

Modifier main.py pour ajouter les nouvelles routes et stocker db_pool dans app.state.

1. Ajouter en haut du fichier, apr√®s les imports existants :

from fastapi.responses import HTMLResponse
from api.routes import router as api_router
from web.dashboard import render_dashboard

2. Apr√®s la d√©finition de app = FastAPI(), ajouter :

# Inclure routes API
app.include_router(api_router)

3. Dans la fonction startup(), modifier pour stocker db_pool dans app.state :

@app.on_event("startup")
async def startup():
    global db_pool
    print("üöÄ Starting Shelly Collector...", flush=True)
    db_pool = await create_db_pool(
        config.DATABASE_URL,
        config.DB_POOL_MIN_SIZE,
        config.DB_POOL_MAX_SIZE
    )
    # Stocker dans app.state pour acc√®s depuis les routes API
    app.state.db_pool = db_pool

4. Apr√®s la route GET /, ajouter :

@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard():
    """Interface web de visualisation des cycles de pompes."""
    return render_dashboard()


TESTS DE VALIDATION
===================

1. ‚úÖ Application d√©marre sans erreur
   - V√©rifier logs : Pas d'erreur d'import, pas de syntax error

2. ‚úÖ Config mise √† jour
   - V√©rifier config.py contient SHELLY_DEVICE_ID

3. ‚úÖ API fonctionne
   - Tester : GET http://localhost:8000/api/pump-cycles
   - Attendu : JSON avec structure {"total": X, "device_id": "shellypro4pm-xxx", "cycles": [...]}
   - V√©rifier logs : "üìä API: Fetched X records" et "üîç API: Detected X cycles"

4. ‚úÖ Dashboard accessible
   - Ouvrir : http://localhost:8000/dashboard
   - Attendu : Page HTML avec header vert FiltrePlante

5. ‚úÖ Filtres par d√©faut
   - Dashboard doit charger automatiquement les 45 derniers jours
   - Dates pr√©-remplies dans les inputs

6. ‚úÖ Filtre par canal
   - S√©lectionner "Canal 2" (switch:2)
   - Cliquer "Rafra√Æchir"
   - Attendu : Tableau affiche uniquement switch:2

7. ‚úÖ Filtre par date
   - S√©lectionner date sp√©cifique (ex: 13/02/2026)
   - Cliquer "Rafra√Æchir"
   - Attendu : Cycles du jour uniquement

8. ‚úÖ Export CSV
   - Cliquer "Exporter CSV"
   - Attendu : T√©l√©chargement fichier cycles_pompes_filtreplante_YYYY-MM-DD.csv
   - Ouvrir fichier : colonnes s√©par√©es par point-virgule (;)

9. ‚úÖ Cycles en cours
   - Si une pompe tourne actuellement
   - Attendu : Ligne avec "En cours ‚ö°" dans colonne Arr√™t
   - Badge canal avec couleur (bleu/violet/orange selon canal)

10. ‚úÖ Statistiques
    - V√©rifier les 4 cards : Total, En cours, Dur√©e moyenne, Puissance moyenne
    - Attendu : Chiffres coh√©rents avec les donn√©es du tableau

11. ‚úÖ Responsive
    - Ouvrir dashboard sur mobile (ou r√©duire fen√™tre < 768px)
    - Attendu : Mise en page adapt√©e, tableau scrollable

12. ‚úÖ Style FiltrePlante
    - Header : d√©grad√© vert #2d8659 ‚Üí #1a5738
    - Bouton primaire : vert #2d8659
    - Hover bouton : effet ombre verte
    - Badges canaux : couleurs pastel (bleu/violet/orange)

13. ‚úÖ Pas de r√©gression
    - WebSocket /ws fonctionne toujours
    - Route / (health check) fonctionne toujours
    - Logs existants inchang√©s

LIVRABLES
=========
- config.py modifi√© (+2 lignes : SHELLY_DEVICE_ID)
- services/cycle_detector.py cr√©√© (~100 lignes, avec datetime.now(timezone.utc))
- api/__init__.py cr√©√© (vide)
- api/routes.py cr√©√© (~85 lignes, utilise app.state.db_pool)
- web/__init__.py cr√©√© (vide)
- web/dashboard.py cr√©√© (~450 lignes HTML/CSS/JS inline)
- main.py modifi√© (+8 lignes : imports, router, dashboard route, app.state.db_pool)
- Dashboard accessible sur /dashboard
- API accessible sur /api/pump-cycles
- Style FiltrePlante (vert #2d8659, moderne, clean)
- Export CSV fonctionnel (format fran√ßais)
- D√©tection cycles : gap 3min, dur√©e min 2min, 45 jours par d√©faut
- Timezone : UTC+0 (S√©n√©gal, pas de conversion)
- Pas d'import circulaire (db_pool via app.state)
- Python 3.12+ compatible (datetime.now(timezone.utc))

POINTS D'ATTENTION
==================
1. Le db_pool est accessible via app.state.db_pool (pas d'import circulaire)
2. Utilisation de datetime.now(timezone.utc) au lieu de datetime.utcnow() (deprecated)
3. Le device_id est centralis√© dans config.SHELLY_DEVICE_ID
4. Les channels sont au format "switch:0", "switch:1", "switch:2" (coh√©rent avec la DB)
5. Les timestamps sont en UTC (coh√©rent avec la base de donn√©es)
6. L'export CSV utilise le point-virgule (standard fran√ßais)
7. Les badges de canal utilisent des classes CSS avec tiret (switch-0 au lieu de switch:0)
8. Le dashboard est enti√®rement self-contained (pas de CDN externe, pas de d√©pendances)
‚úÖ AM√âLIORATIONS APPORT√âES
Par rapport au brief initial :
‚úÖ datetime.now(timezone.utc) au lieu de datetime.utcnow() (Python 3.12+)
‚úÖ app.state.db_pool au lieu d'import circulaire
‚úÖ config.SHELLY_DEVICE_ID centralis√© (DRY principle)
‚úÖ Clarifications suppl√©mentaires dans les commentaires
üéØ CHECKLIST FINALE
 App d√©marre sans erreur
 Config contient SHELLY_DEVICE_ID
 API /api/pump-cycles retourne JSON
 Dashboard /dashboard affiche la page
 Style vert FiltrePlante appliqu√©
 Filtres fonctionnent
 Export CSV fonctionne
 Statistiques correctes
 Responsive
 Pas de r√©gression