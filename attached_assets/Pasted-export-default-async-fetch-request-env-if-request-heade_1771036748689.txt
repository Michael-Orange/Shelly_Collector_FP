export default {
  async fetch(request, env) {
    if (request.headers.get("Upgrade") === "websocket") {
      return handleWebSocket(request, env);
    }
    return new Response("Shelly Filter Proxy - WebSocket only", { status: 200 });
  },
};

function shouldForwardMessage(data) {
  const channelsInclude = [0, 1, 2];
  const powerThreshold = 10;

  if (data && data.params) {
    for (const ch of channelsInclude) {
      const sw = data.params[`switch:${ch}`];
      if (sw && typeof sw.apower === "number" && sw.apower > powerThreshold) {
        return true;
      }
    }
  }
  return false;
}

async function handleWebSocket(request, env) {
  const pair = new WebSocketPair();
  const client = pair[0];
  const server = pair[1];
  server.accept();
  console.log("‚úÖ Shelly connected");

  const backendUrl = "wss://shelly-collector.filtreplante.com/ws";

  let backend = null;
  let backendOpen = false;
  let isConnecting = false;
  let lastAttemptTime = 0;
  let consecutiveFailures = 0;
  const messageQueue = [];
  const MAX_QUEUE_SIZE = 200; // Augment√© pour jours sans activit√©

  let filteredCount = 0;
  let forwardedCount = 0;

  // Backoff exponentiel : 5s ‚Üí 10s ‚Üí 20s ‚Üí 40s ‚Üí 60s (max)
  function getRetryDelay() {
    const baseDelay = 5000;
    const maxDelay = 60000; // 60 secondes max entre retries
    return Math.min(baseDelay * Math.pow(2, Math.min(consecutiveFailures, 4)), maxDelay);
  }

  function addToQueue(message) {
    if (messageQueue.length >= MAX_QUEUE_SIZE) {
      messageQueue.shift();
      if (messageQueue.length % 50 === 0) {
        console.log(`‚ö†Ô∏è Queue: ${messageQueue.length}/${MAX_QUEUE_SIZE}`);
      }
    }
    messageQueue.push(message);
  }

  function sendQueuedMessages() {
    let sent = 0;
    while (backendOpen && messageQueue.length > 0) {
      const msg = messageQueue.shift();
      try {
        backend.send(msg);
        sent++;
      } catch (e) {
        console.error("‚ùå Send queued failed:", e.message);
        messageQueue.unshift(msg); // Remettre en t√™te
        break;
      }
    }
    if (sent > 0) {
      console.log(`‚úÖ Sent ${sent} queued messages (${messageQueue.length} remaining)`);
    }
  }

  function ensureBackend() {
    // D√©j√† connect√© ou en cours
    if (backend || isConnecting) {
      return;
    }

    // Respecter le d√©lai de backoff
    const now = Date.now();
    const requiredDelay = getRetryDelay();
    const timeSinceLastAttempt = now - lastAttemptTime;
    
    if (timeSinceLastAttempt < requiredDelay) {
      return; // Trop t√¥t pour retry
    }

    lastAttemptTime = now;
    isConnecting = true;
    
    const attemptNum = consecutiveFailures + 1;
    console.log(`üîÑ Connection attempt #${attemptNum} (backoff: ${requiredDelay/1000}s, queue: ${messageQueue.length})`);

    try {
      backend = new WebSocket(backendUrl);
    } catch (e) {
      console.error(`‚ùå WebSocket creation failed:`, e.message);
      isConnecting = false;
      consecutiveFailures++;
      return;
    }

    // Timeout G√âN√âREUX pour cold starts Replit Autoscale
    const timeout = setTimeout(() => {
      if (isConnecting) {
        console.error(`‚è±Ô∏è Connection timeout (90s) on attempt #${attemptNum}`);
        isConnecting = false;
        consecutiveFailures++;
        if (backend) {
          try { backend.close(); } catch {}
          backend = null;
        }
      }
    }, 90000); // 90 secondes

    backend.addEventListener("open", () => {
      clearTimeout(timeout);
      backendOpen = true;
      isConnecting = false;
      const prevFailures = consecutiveFailures;
      consecutiveFailures = 0; // Reset sur succ√®s
      console.log(`‚úÖ Backend connected! (after ${prevFailures} failures)`);
      sendQueuedMessages();
    });

    backend.addEventListener("message", (ev) => {
      try {
        server.send(ev.data);
        console.log("üì® Relayed backend‚ÜíShelly");
      } catch (e) {
        console.error("‚ùå Relay failed:", e.message);
      }
    });

    backend.addEventListener("close", (e) => {
      clearTimeout(timeout);
      console.log(`üîå Backend closed: ${e.code} ${e.reason || ''}`);
      backendOpen = false;
      isConnecting = false;
      backend = null;
      consecutiveFailures++;
    });

    backend.addEventListener("error", (e) => {
      clearTimeout(timeout);
      console.error(`‚ùå Backend error`);
      backendOpen = false;
      isConnecting = false;
      backend = null;
      consecutiveFailures++;
    });
  }

  // ‚úÖ RETRY P√âRIODIQUE : r√©essaie toutes les 10s si messages en queue
  const retryInterval = setInterval(() => {
    if (!backendOpen && messageQueue.length > 0) {
      ensureBackend();
    }
  }, 10000); // Check toutes les 10 secondes

  server.addEventListener("message", (ev) => {
    let data;
    let text;
    
    try {
      text = typeof ev.data === 'string' ? ev.data : new TextDecoder().decode(ev.data);
      data = JSON.parse(text);
    } catch {
      return;
    }

    if (!shouldForwardMessage(data)) {
      filteredCount++;
      if (filteredCount % 200 === 0) {
        console.log(`üîΩ ${filteredCount} messages filtered`);
      }
      return;
    }

    forwardedCount++;
    if (forwardedCount % 10 === 0) {
      console.log(`‚ö° ${forwardedCount} messages to forward`);
    }

    if (backendOpen) {
      try {
        backend.send(text);
      } catch (e) {
        console.error("‚ùå Send failed:", e.message);
        addToQueue(text);
      }
    } else {
      addToQueue(text);
      ensureBackend(); // Tente de se connecter
    }
  });

  server.addEventListener("close", () => {
    clearInterval(retryInterval);
    console.log(`üëã Shelly disconnected - Filtered: ${filteredCount}, Forwarded: ${forwardedCount}, Queued: ${messageQueue.length}`);
    if (backend) {
      try { backend.close(); } catch {}
      backend = null;
    }
    messageQueue.length = 0;
  });

  server.addEventListener("error", (e) => {
    console.error("‚ùå Shelly WS error");
  });

  return new Response(null, { status: 101, webSocket: client });
}