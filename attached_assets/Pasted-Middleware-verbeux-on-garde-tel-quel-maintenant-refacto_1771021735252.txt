Middleware verbeux ‚Üí on garde tel quel maintenant (refacto future possible)
Pydantic schemas ‚Üí pr√©paration pour le dashboard (pas utilis√© dans WS pour l'instant)
Config dashboard ‚Üí anticipation intelligente
üìã BRIEF 1 CORRIG√â
Copie-colle ce bloc dans Replit Agent :
CONTEXTE
========
Application Shelly_Collector_FP actuellement dans un seul fichier main.py (166 lignes).
Stack : FastAPI + asyncpg + PostgreSQL + WebSocket pour collecte donn√©es Shelly Pro 4PM.
Objectif : Restructurer l'architecture AVANT d'ajouter le dashboard pour garantir la maintenabilit√©.

‚ö†Ô∏è CONTRAINTE CRITIQUE : L'application doit continuer √† fonctionner exactement comme avant.
Aucune feature ajout√©e, aucun comportement modifi√©. Juste r√©organiser le code existant.
Tous les tests de connexion WebSocket et d'insertion DB doivent passer apr√®s refacto.

‚ö†Ô∏è IMPORTANT : Conserver les commandes RPC bootstrap envoy√©es √† la connexion WebSocket
(NotifyStatus enable et Shelly.GetStatus) pour que le device Shelly commence √† envoyer des donn√©es.

OBJECTIF
========
Refactoriser l'application en architecture modulaire propre :
- S√©parer configuration, services, mod√®les
- Rendre le code testable et r√©utilisable
- Pr√©parer l'ajout futur du dashboard (Temps 2)
- Garder main.py < 100 lignes (orchestration seulement)

SP√âCIFICATIONS
===============

1. STRUCTURE DE DOSSIERS √Ä CR√âER
---------------------------------
shelly_collector_fp/
‚îú‚îÄ‚îÄ main.py                    (refactoris√©, ~80-100 lignes)
‚îú‚îÄ‚îÄ config.py                  (nouveau, ~30 lignes)
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py           (nouveau, vide ou exports)
‚îÇ   ‚îî‚îÄ‚îÄ database.py           (nouveau, ~100 lignes)
‚îî‚îÄ‚îÄ models/
    ‚îú‚îÄ‚îÄ __init__.py           (nouveau, vide ou exports)
    ‚îî‚îÄ‚îÄ schemas.py            (nouveau, ~40 lignes)

2. FICHIER : config.py
----------------------
Cr√©er dans le dossier racine √† c√¥t√© de main.py.

Contenu :

import os

# Database
DATABASE_URL = os.getenv("DATABASE_URL")
DB_POOL_MIN_SIZE = 1
DB_POOL_MAX_SIZE = 3

# Application
THROTTLE_INTERVAL_SECONDS = 60
HEALTH_CHECK_PATHS = ["/", "/health"]
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")

# Future dashboard config
GAP_THRESHOLD_MINUTES = 3
MIN_CYCLE_DURATION_MINUTES = 2
DEFAULT_DAYS_HISTORY = 45

Pourquoi : Centraliser toute la configuration en un seul endroit, faciliter les ajustements futurs.

3. FICHIER : models/schemas.py
-------------------------------
Cr√©er le dossier models/ avec __init__.py vide.

Contenu de schemas.py :

from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional

class PowerLogData(BaseModel):
    """Mod√®le de donn√©es pour un log de consommation √©lectrique Shelly"""
    device_id: str = Field(..., description="ID unique du device Shelly")
    channel: str = Field(..., description="Canal de l'appareil (ex: switch:0)")
    apower_w: float = Field(..., ge=0, description="Puissance active en Watts")
    voltage_v: float = Field(..., ge=0, description="Tension en Volts")
    current_a: float = Field(..., ge=0, description="Courant en Amp√®res")
    energy_total_wh: float = Field(..., ge=0, description="√ânergie totale cumul√©e en Wh")
    timestamp: datetime = Field(..., description="Timestamp de la mesure")

    class Config:
        json_schema_extra = {
            "example": {
                "device_id": "shellypro4pm-a0dd6c9ef474",
                "channel": "switch:1",
                "apower_w": 430.5,
                "voltage_v": 230.0,
                "current_a": 1.87,
                "energy_total_wh": 15420.0,
                "timestamp": "2026-02-13T14:30:00Z"
            }
        }

Note : Ces schemas ne sont PAS utilis√©s dans le WebSocket handler actuel (parsing JSON direct).
Ils sont pr√©par√©s pour le dashboard (Temps 2) et futures validations.

4. FICHIER : services/database.py
----------------------------------
Cr√©er le dossier services/ avec __init__.py vide.

Contenu de database.py :

import asyncpg
from datetime import datetime
from typing import Dict, Optional

async def create_db_pool(database_url: str, min_size: int, max_size: int):
    """
    Cr√©e et retourne un pool de connexions PostgreSQL.
    
    Args:
        database_url: URL de connexion PostgreSQL
        min_size: Taille minimale du pool
        max_size: Taille maximale du pool
        
    Returns:
        asyncpg.Pool: Pool de connexions
        
    Raises:
        Exception: Si la connexion √©choue
    """
    try:
        pool = await asyncpg.create_pool(
            database_url,
            min_size=min_size,
            max_size=max_size
        )
        print("‚úÖ Database pool created successfully", flush=True)
        return pool
    except Exception as e:
        print(f"‚ùå Failed to create database pool: {e}", flush=True)
        raise

async def close_db_pool(pool: asyncpg.Pool):
    """Ferme proprement le pool de connexions."""
    if pool:
        try:
            await pool.close()
            print("‚úÖ Database pool closed", flush=True)
        except Exception as e:
            print(f"‚ö†Ô∏è Error closing pool: {e}", flush=True)

def should_throttle(
    last_write_time: Dict[str, datetime],
    device_id: str,
    channel: str,
    throttle_seconds: int,
    current_time: datetime
) -> bool:
    """
    D√©termine si un enregistrement doit √™tre throttl√© (ignor√©).
    
    Args:
        last_write_time: Dictionnaire des derni√®res √©critures {key: timestamp}
        device_id: ID du device
        channel: Canal
        throttle_seconds: Intervalle de throttling en secondes
        current_time: Timestamp actuel
        
    Returns:
        bool: True si doit throttle, False sinon
    """
    key = f"{device_id}_{channel}"
    
    if key not in last_write_time:
        last_write_time[key] = current_time
        return False
    
    elapsed = (current_time - last_write_time[key]).total_seconds()
    
    if elapsed >= throttle_seconds:
        last_write_time[key] = current_time
        return False
    
    return True

async def insert_power_log(
    pool: asyncpg.Pool,
    device_id: str,
    channel: str,
    apower_w: float,
    voltage_v: float,
    current_a: float,
    energy_total_wh: float,
    timestamp: datetime
) -> bool:
    """
    Ins√®re un log de consommation √©lectrique dans la base de donn√©es.
    
    Args:
        pool: Pool de connexions asyncpg
        device_id, channel, apower_w, voltage_v, current_a, energy_total_wh, timestamp: Donn√©es √† ins√©rer
        
    Returns:
        bool: True si insertion r√©ussie, False sinon
    """
    # Arrondir le timestamp √† la minute
    rounded_timestamp = timestamp.replace(second=0, microsecond=0)
    
    try:
        async with pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO power_logs 
                (timestamp, device_id, channel, apower_w, voltage_v, current_a, energy_total_wh)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
                """,
                rounded_timestamp,
                device_id,
                channel,
                apower_w,
                voltage_v,
                current_a,
                energy_total_wh
            )
        return True
    except Exception as e:
        print(f"‚ùå Error inserting log: {e}", flush=True)
        return False

5. FICHIER : main.py (REFACTORIS√â)
-----------------------------------
R√©duire main.py √† l'orchestration uniquement.

‚ö†Ô∏è ATTENTION SP√âCIALE : Conserver les commandes RPC bootstrap envoy√©es apr√®s websocket.accept() :
- Commande 1 : NotifyStatus enable (pour activer les notifications)
- Commande 2 : Shelly.GetStatus (pour obtenir l'√©tat initial)

Ces commandes sont CRITIQUES pour que le Shelly commence √† envoyer des donn√©es.

Structure cible du main.py refactoris√© :

from fastapi import FastAPI, WebSocket, Request
from fastapi.responses import PlainTextResponse
from datetime import datetime
import json
import time

# Imports des modules cr√©√©s
import config
from services.database import create_db_pool, close_db_pool, should_throttle, insert_power_log

app = FastAPI()

# Variables globales
db_pool = None
last_write_time = {}

# MIDDLEWARE : COPIER EXACTEMENT le middleware existant depuis l'ancien main.py
# Ne rien changer aux logs, garder le filtrage des health checks
@app.middleware("http")
async def log_requests(request: Request, call_next):
    # [COPIER LE CONTENU EXACT DU MIDDLEWARE EXISTANT]
    # Doit inclure : d√©tection cold start, logging IP/user-agent, filtrage health checks, etc.
    pass

# ROUTE HEALTH CHECK
@app.get("/")
async def health_check():
    return PlainTextResponse("Shelly WebSocket Collector is running")

# ROUTE WEBSOCKET
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    print(f"‚úÖ WebSocket connection accepted", flush=True)
    
    # ‚ö†Ô∏è CRITICAL : Envoyer les commandes RPC bootstrap
    # Ces commandes doivent √™tre envoy√©es IMM√âDIATEMENT apr√®s accept()
    try:
        # Commande 1 : Activer NotifyStatus
        await websocket.send_json({
            "id": 1,
            "method": "NotifyStatus",
            "params": {"enable": True}
        })
        print("üì§ Sent: NotifyStatus enable", flush=True)
        
        # Commande 2 : Obtenir l'√©tat initial
        await websocket.send_json({
            "id": 2,
            "method": "Shelly.GetStatus"
        })
        print("üì§ Sent: Shelly.GetStatus", flush=True)
    except Exception as e:
        print(f"‚ùå Error sending bootstrap commands: {e}", flush=True)
    
    # Boucle de r√©ception des messages
    try:
        while True:
            data = await websocket.receive_text()
            
            try:
                message = json.loads(data)
            except json.JSONDecodeError:
                print(f"‚ö†Ô∏è Invalid JSON received", flush=True)
                continue
            
            # V√©rifier structure message Shelly
            if message.get("method") != "NotifyStatus" or "params" not in message:
                continue
            
            params = message["params"]
            device_id = message.get("src", "unknown")
            current_time = datetime.utcnow()
            
            # Traiter chaque switch
            for key, value in params.items():
                if not key.startswith("switch:"):
                    continue
                
                channel = key
                apower = value.get("apower")
                
                if apower is None:
                    continue
                
                # Throttling
                if should_throttle(
                    last_write_time,
                    device_id,
                    channel,
                    config.THROTTLE_INTERVAL_SECONDS,
                    current_time
                ):
                    print(f"‚è≠Ô∏è Throttled: {device_id} {channel}", flush=True)
                    continue
                
                # Insertion en DB
                success = await insert_power_log(
                    db_pool,
                    device_id,
                    channel,
                    apower,
                    value.get("voltage", 0.0),
                    value.get("current", 0.0),
                    value.get("aenergy", {}).get("total", 0.0),
                    current_time
                )
                
                if success:
                    print(f"‚úÖ Logged: {device_id} {channel} {apower}W", flush=True)
    
    except Exception as e:
        print(f"‚ùå WebSocket error: {e}", flush=True)
    finally:
        print(f"üîå WebSocket disconnected", flush=True)

# STARTUP / SHUTDOWN
@app.on_event("startup")
async def startup():
    global db_pool
    print("üöÄ Starting Shelly Collector...", flush=True)
    db_pool = await create_db_pool(
        config.DATABASE_URL,
        config.DB_POOL_MIN_SIZE,
        config.DB_POOL_MAX_SIZE
    )

@app.on_event("shutdown")
async def shutdown():
    print("üõë Shutting down...", flush=True)
    await close_db_pool(db_pool)

Objectif : main.py doit faire ~90-100 lignes (un peu plus √† cause des commandes bootstrap), lisible, orchestration pure.

R√àGLES DE MIGRATION STRICTES
=============================
1. ‚ö†Ô∏è COPIER-COLLER le middleware existant sans modification
2. ‚ö†Ô∏è GARDER tous les print() existants avec flush=True
3. ‚ö†Ô∏è GARDER le filtre health checks dans le middleware (ne pas logger /, /health)
4. ‚ö†Ô∏è GARDER la logique throttle identique (dictionnaire last_write_time)
5. ‚ö†Ô∏è GARDER l'arrondi timestamp .replace(second=0, microsecond=0) dans database.py
6. ‚ö†Ô∏è GARDER les param√®tres pool (min=1, max=3)
7. ‚ö†Ô∏è GARDER les commandes RPC bootstrap (NotifyStatus enable + Shelly.GetStatus)
8. ‚ö†Ô∏è NE PAS modifier la structure de la table power_logs
9. ‚ö†Ô∏è NE PAS ajouter de d√©pendances (tout utilise asyncpg, fastapi, pydantic d√©j√† pr√©sents)

TESTS DE VALIDATION POST-REFACTO
=================================
V√©rifier imp√©rativement que :

1. ‚úÖ Application d√©marre sans erreur
   - V√©rifier : "üöÄ Starting Shelly Collector..." puis "‚úÖ Database pool created successfully"

2. ‚úÖ Route health check fonctionne
   - Tester : curl http://localhost:8000/
   - Attendu : "Shelly WebSocket Collector is running"

3. ‚úÖ WebSocket accepte connexions
   - V√©rifier logs : "‚úÖ WebSocket connection accepted"

4. ‚úÖ Commandes RPC bootstrap envoy√©es
   - V√©rifier logs : "üì§ Sent: NotifyStatus enable" puis "üì§ Sent: Shelly.GetStatus"

5. ‚úÖ Insertion DB fonctionne
   - Envoyer message test Shelly via WebSocket
   - V√©rifier logs : "‚úÖ Logged: shellypro4pm-xxx switch:X XXXW"
   - V√©rifier en DB : SELECT COUNT(*) FROM power_logs doit augmenter

6. ‚úÖ Throttling fonctionne
   - Envoyer 2 messages identiques rapidement
   - V√©rifier logs : "‚è≠Ô∏è Throttled: ..." sur le 2√®me message

7. ‚úÖ Middleware logs fonctionne
   - V√©rifier logs HTTP avec IP, user-agent, cold start detection

8. ‚úÖ Pas de r√©gression performance
   - Temps r√©ponse health check < 100ms
   - Latence WebSocket identique

9. ‚úÖ Shelly device envoie bien des donn√©es
   - Si un Shelly est connect√©, v√©rifier que les mesures arrivent toujours
   - Si pas de donn√©es apr√®s 2-3 minutes ‚Üí probl√®me avec les commandes bootstrap

LIVRABLES
=========
- 4 nouveaux fichiers : config.py, services/database.py, models/schemas.py, __init__.py (x2)
- main.py refactoris√© (~90-100 lignes)
- Application 100% fonctionnelle √† l'identique
- Commandes RPC bootstrap pr√©serv√©es
- Logs et comportement inchang√©s
- Base propre pour ajouter le dashboard (Temps 2)